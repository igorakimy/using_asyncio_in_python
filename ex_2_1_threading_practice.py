from concurrent.futures import ThreadPoolExecutor as Executor


def worker(data):
    # Какая-то логика обработки данных
    ...


with Executor(max_workers=10) as exe:
    data = [1, 2, 3, 4]
    future = exe.submit(worker, data)

# Самыми стержневым механизмом распараллеливания в существующем API Windows
# являются именно потоки. Обычно для создания потоков вы применяете функцию
# CreateThread. Хотя потоки относительно просты для создания и применения,
# сама операционная система уделяет значительное время и прочие ресурсы для
# управления ими. Кроме того, хотя каждому потоку гарантируется получение
# точно такого же времени исполнения, что и для остальных потоков с тем
# же самым уровнем приоритета, а связанные с ними накладные расходы требуют
# того, что бы создавала достаточно большие задачи. Для задач меньшего размера
# или с большей степенью детализации, те накладные расходы, которые связаны с
# распараллеливанием, могут перевешивать те преимущества, которые получают
# одновременно исполняемые задачи.

# Потоки имеют действительную стоимость для ваших программ (и всей системы)
# в терминах использования памяти и производительности. Каждый поток требует
# соответствующего выделения памяти как в пространстве самого ядра, так и в
# пространстве памяти вашей программы. Имеющиеся структуры ядра требуют
# управления вашим потоком и координации их планирования запоминаются в самом
# ядре при помощи зашитой памяти. Ваше пространство стека потока и данных
# каждого потока сохраняются в пространстве памяти вашей программы. Большая
# часть этих структур создаются и инициализируются при создании самом первом
# вашего потока - некого процесса, который может быть относительно затратным,
# так как он требует взаимодействия с самим ядром.
