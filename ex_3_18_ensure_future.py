import asyncio


# Простая функция сопрограммы, которая ничего не делает. Нам просто нужно что-то,
# что может создать сопрограмму.
async def f():
    pass


if __name__ == '__main__':
    # Мы создаем объект сопрограммы, вызывая функцию напрямую. Ваш код будет редко делать
    # это, но я хочу пояснить здесь (несколькими строками ниже), что мы передаем объект
    # сопрограммы в каждый из методов: create_task() и ensure_future().
    coro = f()

    # Получаем цикл событий.
    loop = asyncio.get_event_loop()

    # Во-первых, мы используем loop.create_task(), чтобы запланировать нашу сопрограмму в
    # цикле, и мы получаем обратно новый экземпляр задачи.
    task = loop.create_task(coro)
    # Мы проверяем тип. Пока ничего интересного.
    assert isinstance(task, asyncio.Task)

    # Мы показываем, что asyncio.ensure_future() можно использовать для выполнения того же
    # действия, что и create_task(): мы передали сопрограмму и получили обратно экземпляр
    # Task (и сопрограмма была запланирована для запуска в цикле)! Если вы передаете в
    # сопрограмме, нет никакой разницы между loop.create_task() и asyncio.ensure_future().
    new_task = asyncio.ensure_future(coro)
    assert isinstance(new_task, asyncio.Task)

    # Но что произойдет, если мы передадим экземпляр Task в ensure_future()? Обратите внимание,
    # что мы передаем экземпляр Task, который уже был создан с помощью loop.create_task() выше.
    mystery_meat = asyncio.ensure_future(task)
    # Мы получаем обратно точно тот же экземпляр Task, который мы передали: он не изменился.
    assert mystery_meat is task
