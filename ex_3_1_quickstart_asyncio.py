import time
import asyncio


async def main():
    print(f'{time.ctime()} Hello!')
    await asyncio.sleep(1.0)
    print(f'{time.ctime()} Goodbye!')


if __name__ == '__main__':
    # loop = asyncio.get_event_loop()
    # Вам нужен экземпляр цикла событий, прежде чем вы сможете запускать какие-либо сопрограммы
    # и вот как вы его можете получить. На самом деле, где бы вы это ни вызывали, get_event_loop()
    # отдаст вам тот же самый экземпляр цикла каждый раз, пока вы используете только один поток.
    # Если вы находитесь внутри async def функции, вам следует вызывать asyncio.get_running_loop(),
    # который всегда дает вам то, что вы ожидаете.
    loop = asyncio.get_event_loop()

    # task = loop.create_task(coro)
    # В этом случае конкретным вызовом является loop.create_task(main()). Ваша функция сопрограммы
    # не будет выполнена, пока вы этого не сделаете. Мы говорим, что create_task() планирует
    # выполнение вашей сопрограммы в цикле событий. Возвращаемый объект task может использоваться
    # для отслеживания статуса задачи (например, выполняется ли она все еще или завершена), а
    # также может использоваться для получения значения результата из вашей завершенной сопрограммы.
    # Вы можете отменить задачу с помощью task.cancel().
    task = loop.create_task(main())

    # loop.run_until_complete(coro)
    # Этот вызов заблокирует текущий поток, который обычно является основным потоком. Обратите
    # внимание, что run_until_complete() будет поддерживать выполнение цикла только до завершения
    # переданной сопрограммы, но все другие задачи, запланированные в цикле, также будут выполняться
    # во время выполнения цикла. Внутренне asyncio.run() вызывает run_until_complete() для вас и,
    # следовательно, блокирует основной поток таким же образом.
    loop.run_until_complete(task)

    pending = asyncio.all_tasks(loop=loop)
    for task in pending:
        task.cancel()

    # group = asyncio.gather(task1, task2, task3)
    # Когда "основная" часть программы разблокируется либо из-за приема сигнала процесса, либо из-за
    # остановки цикла событий каким-либо кодом, вызывающим loop.stop(), будет запущен код после
    # run_until_complete(). Стандартная идиома, показанная здесь, заключается в том, чтобы собрать
    # все еще ожидающие задачи, отменить их, а затем использовать loop.run_until_complete() снова,
    # до тех пор пока эти задачи не будут выполнены. gather() - это метод для выполнения сбора.
    # Обратите внимание, что asyncio.run() выполнит все операции отмены, сбора и ожидания завершения
    # отложенных задач.
    group = asyncio.gather(*pending, return_exceptions=True)
    loop.run_until_complete(group)

    # loop.close() обычно является заключительным действием: оно должно быть вызвано в остановленном
    # цикле событий, очистит все очереди и завершит работу исполнителя. Остановленный цикл может быть
    # восстановлен, но закрытый (closed) цикл исчезнет навсегда. Внутренне asyncio.run() закроет цикл
    # событий перед возвратом. Это нормально, потому что run() создает новый цикл событий каждый раз,
    # когда вы его вызываете.
    loop.close()

    # Mon Nov  7 09:45:31 2022 Hello!
    # Mon Nov  7 09:45:32 2022 Goodbye!
