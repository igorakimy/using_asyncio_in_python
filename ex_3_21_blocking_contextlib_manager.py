from contextlib import contextmanager
import httpx


url_stat = {
    'https://yandex.ru': 0
}


def download_webpage(url):
    resp = httpx.get(url, follow_redirects=True)
    return resp.text


def update_stats(url):
    url_stat[url] = url_stat.get(url) + 1


def process(data):
    print(data[:6])


# Декоратор @contextmanager преобразует генераторную функцию в контекстный менеджер.
@contextmanager
def web_url(url):
    # Этот вызов функции подозрительно похож на то, что нужно для использования сетевого
    # интерфейса, который на много порядков медленнее, чем "обычный код", привязанный к
    # процессору. Этот контекстный менеджер должен использоваться в выделенном потоке; в
    # противном случае вся программа будет приостановлена в ожидании данных.
    data = download_webpage(url)
    yield data
    # Представьте, то мы обновляем некоторую статистику каждый раз, когда обрабатываем
    # данные с URL-адреса, например, количество раз, когда URL-адрес был загружен. С
    # точки зрения конкурентности нам нужно было бы знать, включает ли эта функция
    # внутренний ввод-вывод, например запись в базу данный по сети. Если это так,
    # update_stats() также является блокирующим вызовом.
    update_stats(url)


if __name__ == '__main__':
    # Здесь используется наш контекстный менеджер. Обратите особое внимание на то, как
    # сетевой вызов download_webpage() скрыт внутри конструкции контекстного менеджера.
    with web_url('https://yandex.ru') as data:
        # Этот вызов функции process() также может быть блокирующим. Мы должны были бы
        # посмотреть на то, что делает функция, потому что различие между тем, что
        # блокирует или не блокирует, не является четким. Это может быть:
        # - Безвредный и неблокирующий (быстрый и привязанный к процессору)
        # - Частично блокирующий (быстрый и связанный с вводом-выводом, возможно, что-то
        #   вроде быстрого доступа к диску вместо сетевого ввода-вывода)
        # - Блокирующий (медленный и связан с вводом-выводом)
        # - Дьявольский (медленный и привязанный к процессору) Для простоты в этом
        #   примере давайте предположим, что вызов process() это быстрая операция,
        #   привязанная к процессору и, следовательно, неблокирующая.
        process(data)
        # <body>
